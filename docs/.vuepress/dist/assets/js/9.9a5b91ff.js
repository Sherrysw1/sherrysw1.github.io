(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{282:function(e,n,t){"use strict";t.r(n);var a=t(14),r=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"双向绑定"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#双向绑定"}},[e._v("#")]),e._v(" 双向绑定")]),e._v(" "),n("p",[e._v("vue有双向绑定，react没有。vue通过v-model来双向绑定。\n实现原理：Object.defineProperty或Proxy+发布订阅模式\n实现效果：data <=> view")]),e._v(" "),n("h2",{attrs:{id:"过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#过程"}},[e._v("#")]),e._v(" 过程")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/5/23/04fdcd64ed41f762a7a495f73c0a2f86~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp",alt:""}})]),e._v(" "),n("ul",[n("li",[e._v("实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。")]),e._v(" "),n("li",[e._v("实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。")]),e._v(" "),n("li",[e._v("实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("# Observer\nfunction directive(data, key, val) {\n    // 给所有属性绑定observer\n    observer(val);\n    var dep = new Dep();\n    Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function() {\n            // 判断是否需要添加订阅者\n            if (Dep.target) {\n                dep.addWatcher(Dep.target);\n            }\n            return val;\n        },\n        set: function(newVal) {\n            if (val === newVal) return;\n            val = newVal;\n            console.log('dep=', dep);\n            dep.notify();\n        }\n    });\n}\nfunction Dep() {\n    this.watchers = [];\n}\nDep.prototype = {\n    addWatcher: function(watcher) {\n        this.watchers.push(watcher);\n    },\n    notify: function() {\n        this.watchers.forEach(watcher => watcher.update());\n    }\n}\nDep.target = null;\nfunction observer(data) {\n    if (!data || typeof data !== 'object') return;\n    Object.keys(data).forEach(key => directive(data, key, data[key]));\n}\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('# 模板\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n</head>\n<body>\n    <div id="app">\n        <input type="text" v-model="name">\n        {{name}}\n    </div>\n    <script src="./observer.js"><\/script>\n    <script src="./watcher.js"><\/script>\n    <script src="./compiler.js"><\/script>\n    <script type="text/javascript">\n        const myVue = new SelfVue({\n            el: \'#app\',\n            data: {\n                name: \'123\'\n            }\n        });\n\n        function SelfVue(options) {\n            this.data = options.data;\n            observer(this.data);\n            let id = options.el;\n            const el = document.querySelector(id);\n            let dom = nodeToFragment(el, this);\n            // 处理完所有dom节点后,重新将内容添加回去\n            el.appendChild(dom);\n        }\n\n        function nodeToFragment(node, vm) {\n            let fragment = document.createDocumentFragment();\n            let child;\n            while (child = node.firstChild) {\n                compiler(child, vm);\n                fragment.appendChild(child);\n            }\n            return fragment\n        }\n    <\/script>\n</body>\n</html>\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("# watcher实现\n// vm: 模板数据 exp: 要双向绑定的模板变量 cb: 获取更新后需要执行的回调函数\nfunction Watcher(vm, exp, cb) {\n    this.vm = vm;\n    this.cb = cb;\n    this.exp = exp;\n    this.value = this.get(); // 执行get方法，将自己添加到订阅器\n}\nWatcher.prototype = {\n    update: function() {\n        this.run();\n    },\n    run: function() {\n        var value = this.vm.data[this.exp];\n        if (value === this.value) return;\n        this.value = value;\n        this.cb.call(this.vm, value);\n    },\n    get: function() {\n        Dep.target = this;\n        // 执行observer里面的get方法\n        var value = this.vm.data[this.exp];\n        Dep.target = null; // 释放\n        return value;\n    }\n}\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("# 编译\nfunction compiler(node, vm) {\n    let reg = /\\{\\{(.*)\\}\\}/; // 来匹配 {{ xxx }} 中的xxx\n    // 如果是元素节点\n    if (node.nodeType === 1) {\n        let attr = node.attributes;\n        // 解析元素节点的所有属性\n        for (let i = 0; i < attr.length; i++) {\n            if (attr[i].nodeName === 'v-model') {\n                let name = attr[i].nodeValue; // 看看是与哪一个数据相关\n                node.addEventListener('input', function (e) {\n                    vm.data[name] = e.target.value; // 将实例的text 修改为最新值\n                });\n                node.value = vm.data.name; // 将data的值赋给该node\n                node.removeAttribute('v-model');\n            }\n        }\n    }\n    // 如果是文本节点\n    if (node.nodeType === 3) {\n        if (reg.test(node.nodeValue)) {\n            let name = RegExp.$1; // 获取到匹配的字符串\n            name = name.trim();\n            node.nodeValue = vm.data.name;  // 将data的值赋给该node\n            new Watcher(vm, name, function(value) {\n                node.nodeValue = value;\n            }); // 不直接通过赋值的操作，而是通过绑定一个订阅者\n        }\n    }\n}\n")])])]),n("h2",{attrs:{id:"例子"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#例子"}},[e._v("#")]),e._v(" 例子")]),e._v(" "),n("p",[n("RouterLink",{attrs:{to:"/Vue/bindExample/index.html"}},[e._v("线上运行代码")])],1)])}),[],!1,null,null,null);n.default=r.exports}}]);